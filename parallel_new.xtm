
;;; parallel_coordinates.xtm:merged code and example --

;; Author: Noah Ingham
;; Keywords: extempore
;; Required dylibs: libglfw3, libnanovg

;;; Commentary:

;;

;;; Code:
;;(sys:load "libs/external/system.xtm")


;; setup GLFW3 and nanovg
(sys:load "libs/external/glfw3.xtm")
(bind-val width  i32 1600)
(bind-val height i32 800)
(bind-val window GLFWwindow*
  (glfw_init_and_create_interaction_window (convert width) (convert height)))
(sys:load "libs/external/nanovg.xtm")
(bind-val vg NVGcontext* (nvg_create_context))
(bind-val pixel_ratio float (glfw_get_pixel_ratio window))
(sys:load "datavis-lib.xtm")
(call-as-xtlang
 (nvgCreateFont vg "default" "/Library/Fonts/Arial.ttf")
 (nvgFontFace vg "default"))

(bind-func set_bg
   (lambda (vg:NVGcontext*)
     (_nvgFillColor vg (NVGcolor 0.0 0.0 0.0 0.0))
     (nvgBeginPath vg)
     (nvgRect vg 0. 0. (convert width) (convert height))
     (nvgFill vg)))

(dv_draw_axis_labels_2D.font_size 18)

;;(sys:load "libs/core/math_ext.xtm")

(sys:load "csv.xtm")
(sys:load "clustering-kmeans.xtm")

;;(set! current_line:float* (zalloc (+ (* (- n 1) 2) (* 2 n))))

(bind-func log
  (lambda (l:i8*)
    (println l)
    #t
    ))

(bind-val current_line float*)


(bind-val data Data* (load_csv "basic.csv"))


(bind-func draw_parallel_coordinate
  (let (
        (i:i64 0)
        (j:i64 0)
        (k:i64 0)
        (colour1 (NVGcolor .6 .1 .7 0.4))
        (colour2 (NVGcolor .1 .7 .6 0.4))
        (colour3 (NVGcolor .7 .6 .1 0.4))
        (colour4 (NVGcolor .1 .6 .7 0.4))
        (colours (list colour1 colour2 colour3 colour4))
        (axis:Axis* null)
        (offset:float (convert 0))
        (offset2:float (convert 0))
        (range:Range* null)
        (minv:double 0.0)
        (maxv:double 0.0)
        (current:double 0.0)
        (current2:double 0.0)
        (normalized:double 0.0)
        (spacing:double 0.0)
        (spacingn:double 0.0)
        (cluster:i64 0)
        (crange:Range* null)
        (minr:double 0.0)
        (maxr:double 0.0)
        )
    (lambda (bounds:Rect*)
      ;(println "1.1-in")
      (let ((vectors (tuple-ref data 0))
            (n (tuple-ref data 1))
            (axes (tuple-ref data 2))
            (d (tuple-ref data 3))
            (both:BothCCR* (cluster-kmeans data 3))
            (clusters:Clusters (tuple-ref both 0))
            (centroids:Centroids (tuple-ref both 1))
            (ranges:Range** (tuple-ref both 2))
           )
        ;(println "2-in")
        ;(printf "n: %i, d: %i\n" n d)
        (set! i 0)
        (set! j 0)
        (set! k 0)
        (dotimes (i n)
          ;(set! centroid (nth centroids (nth clusters i)))
          (set! cluster (pref clusters i))
          (dotimes (j d)
                ;;(printf "%f\n" current)
                ;(println "...1")
                (set! axis (pref axes j))
                (set! offset (tuple-ref axis 1))
                (set! range (tuple-ref axis 3))
                (set! minv (tuple-ref range 0))
                (set! maxv (tuple-ref range 1))
                (set! current (pref vectors (+ j (* i d))))
                (set! normalized (+ 0.05 (* 0.9 (/ (- current minv) (- maxv minv)))))
                ;(println "...2")
                (pset! current_line (* j 4) (convert (offset)) )
                (pset! current_line (+ (* j 4) 1) (convert normalized) )
                ;(println "...3")

                (if (< j (- d 1))
                  (let ((a #t))
                    (set! offset2 (tuple-ref (pref axes (+ j 1)) 1))
                    (set! current2 (pref centroids (+ j (* cluster d)) ))
                    (set! normalized (+ 0.05 (* 0.9 (/ (- current2 minv) (- maxv minv)))))

                    (set! crange (pref ranges (+ (* cluster d) j)))
                    (set! minr (tref crange 0))
                    (set! maxr (tref crange 1))
                    (set! spacing (- current current2 ))
                    (set! spacingn (* 0.1 (+ 0.05 (* 0.9 (/ (- spacing minv) (- maxv minv))))))
                    ;(set! spacingn (* 0.0 (random)))
                    (pset! current_line (+ (* j 4) 2) (convert (/ (+ offset offset2) (convert 2))) )
                    (pset! current_line (+ (* j 4) 3) (convert (+ spacingn normalized)) )
                  )
                )
                )
          (dv_draw_line_curve vg bounds current_line d (nth colours (pref clusters i)))
          #t
          )
        ;;(free current_line)
        ;(println "2-mid")
        (dotimes (i d)
          ;;(dv_draw_axis_labels_2D vg bounds labs nlabs labs nlabs)
          ;;(dv_draw_axis_2D vg bounds (tuple-ref (nth axes i) 1))
          (dv_draw_axis_2D vg bounds (tuple-ref (pref axes i) 1)))
        ;(println "2-out")
        #t
    ))))















(bind-func transform_data
  (lambda (data:Data*)
    data
    ))


(bind-func draw_barplot
  (let ((nlabs 5)
        (labs:float* (zalloc nlabs))
        (bars:float* (zalloc nlabs))
        (line:float* (zalloc (* 2 nlabs)))
        (i 0))
    (dotimes (i nlabs)
      (pset! labs i (* (convert i) (/ 1. (convert (- nlabs 1)))))
      ;; x positions should be in the middle of the bars
      (pset! line (* i 2) (+ (/ .5 (convert nlabs)) (* (convert i) (/ 1. (convert nlabs))))))
    (lambda (bounds:Rect*)
      (dotimes (i nlabs)
        (pset! bars i (+ .5 (* .3 (cos (* 0.00001 (convert (* (now) (+ i 1))))))))
        (pset! line (+ (* i 2) 1) (+ .5 (* .28 (cos (* 0.00001 (convert (* (now) (+ i 1)))))))))
      (dv_draw_bars vg bounds bars nlabs)
      (dv_draw_axis_labels_2D vg bounds labs nlabs labs nlabs)
      (dv_draw_axes_2D vg bounds)
      (dv_draw_title vg bounds "Barplot")
      (dv_draw_line vg bounds line nlabs null)
      void)))

(bind-func draw_scatterplot
  (let ((npoints 50)
        (points:float* (zalloc (* 2 npoints)))
        (i 0))
    (lambda (bounds:Rect*)
      (dotimes (i npoints)
        (pset! points (* i 2) (+ (* (cos (* .00000064 (convert (* i 2 (now))))) .5) .5))
        ;; (pset! points (+ 1 (* i 2)) (/ (convert i) (convert npoints)))
        (pset! points (+ 1 (* i 2)) (+ .5 (% (* 3.2 (cos (* 0.0000003 (convert (* (now) i) float)))) .5))))
      (dv_draw_scatter_points vg bounds points npoints (+ (* (cos (* .0000053 (convert (now)))) 3.) 5.))
      ;; (dv_draw_axis_labels_2D vg bounds points npoints points npoints)
      (dv_draw_axes_2D vg bounds)
      (dv_draw_title vg bounds "Scatterplot")
      void)))

(bind-func nvg_draw_loop1
  (let ((bar_rect (Rect 0. 0. (* 0.3 (convert width)) (* 0.5 (convert height))))
        (scatter_rect (Rect 0. (* 0.5 (convert height)) (* 0.3 (convert width)) (* 0.5 (convert height))))
        (parallel_rect (Rect (* 0.3 (convert width)) 0. (* 0.7 (convert width)) (convert height)))
        (parity:i64 0))
    (lambda (time:i64 delta_t:double)
      (nvg_clear)
      (set! parity (+ parity 1))
      (nvgBeginFrame vg width height pixel_ratio)
      (nvgResetTransform vg)
      (draw_barplot bar_rect)
      (draw_scatterplot scatter_rect)
      ;(println "1-in")
      ;(println "plotting-in")
      (draw_parallel_coordinate parallel_rect)
      ;(println "plotting-out")
      ;(println "1-out\n")
      (nvgEndFrame vg)
      (set! data (transform_data data))
      (glfwPollEvents)
      (set_bg vg)
      (glfwSwapBuffers window)
      (let ((next_time (+ time (convert (* 44100. delta_t)))))
        (callback next_time nvg_draw_loop1 next_time delta_t)))))

(bind-func run_loop
  (lambda ()
    (let (;(data (load_csv "cars.csv"))
          ;(data2 (load_csv "iris.csv"))
          (n:i64 (tref data 1))
          (c_l:float* (halloc (+ (* (- n 1) 2) (* 2 n))))
          )
      (println "running loop...")
      (set! current_line c_l)
      (nvg_draw_loop1 (now) (/ 1. 30.))
      ;;(nvg_draw_loop1 (+ 2 (now)) (/ 4. 1.) data2)
      )
    ))

(run_loop)

(bind-func setData
  (lambda (name)
    (set! data (load_csv name))
    ))

($ (setData "basic2000.csv"))

(bind-func nvg_draw_loop1
  (lambda (time:i64 delta_t:double)
    void
    ))
