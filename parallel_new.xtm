
;;; parallel_coordinates.xtm:merged code and example --

;; Author: Noah Ingham
;; Keywords: extempore
;; Required dylibs: libglfw3, libnanovg

;;; Commentary:

;;

;;; Code:
;;(sys:load "libs/external/system.xtm")


;; setup GLFW3 and nanovg
(sys:load "libs/external/glfw3.xtm")
(bind-val width  i32 1600)
(bind-val height i32 800)
(bind-val window GLFWwindow*
  (glfw_init_and_create_interaction_window (convert width) (convert height)))
(sys:load "libs/external/nanovg.xtm")
(bind-val vg NVGcontext* (nvg_create_context))
(bind-val pixel_ratio float (glfw_get_pixel_ratio window))

(call-as-xtlang
 (nvgCreateFont vg "default" "/Library/Fonts/Arial.ttf")
 (nvgFontFace vg "default"))

(bind-func set_bg
   (lambda (vg:NVGcontext*)
     (_nvgFillColor vg (NVGcolor 0.0 0.0 0.0 0.0))
     (nvgBeginPath vg)
     (nvgRect vg 0. 0. (convert width) (convert height))
     (nvgFill vg)))

;(dv_draw_axis_labels_2D.font_size 18)

;;(sys:load "libs/core/math_ext.xtm")

(sys:load "csv.xtm")
(sys:load "datavis-lib.xtm")
(sys:load "clustering-kmeans.xtm")

;;(set! current_line:float* (zalloc (+ (* (- n 1) 2) (* 2 n))))

(bind-type Dataset <Data*,Clusters,Centroids>)

(bind-func load_dataset
  (lambda (filename:i8* k:i64)
    (let ((data (load_csv filename))
          (both (cluster-kmeans data k))
          (clusters (tref both 0))
          (centroids (tref both 1)))
          (Dataset_h data clusters centroids))))

(bind-func load_dataset
  (lambda (filename:i8* centroids-old:Centroids k:i64)
    (let ((data (load_csv filename))
          (both (cluster-kmeans data centroids-old k))
          (clusters (tref both 0))
          (centroids (tref both 1)))
          (Dataset_h data clusters centroids))))

(bind-val dataset00 Dataset*)
(bind-val dataset05 Dataset*)
(bind-val dataset10 Dataset*)
(bind-val all_datasets Dataset** 3)
(bind-func set-data
  (lambda ()
    (set! dataset00 (load_dataset "csv/school2000.csv" 3))
    (set! dataset05 (load_dataset "csv/school2005.csv" (tref dataset00 2) 3))
    (set! dataset10 (load_dataset "csv/school2010.csv" (tref dataset05 2) 3))
    (pset! all_datasets 0 dataset00)
    (pset! all_datasets 1 dataset05)
    (pset! all_datasets 2 dataset10)
    ))
(set-data)

;($ (set! data10 (load_csv "csv/school2010.csv")))
(bind-val n i64 (tref (tref dataset00 0) 1))
(bind-val d i64 (tref (tref dataset00 0) 3))
(bind-val global-range Range**)

(bind-func set-global-range
  (lambda ()
    ;(set! global-range (halloc d))
    (let ((i 0)
          (global:Range** (halloc d))
          )
      (dotimes (i d)
        (let ((range (Range 0.0 0.0)))
        (tset! range 0 (min (min (tref (tref (pref (tref (tref dataset00 0) 2) i) 3) 0)
                            (tref (tref (pref (tref (tref dataset05 0) 2) i) 3) 0))
                            (tref (tref (pref (tref (tref dataset10 0) 2) i) 3) 0)
        ))
        (tset! range 1 (max (max (tref (tref (pref (tref (tref dataset00 0) 2) i) 3) 1)
                            (tref (tref (pref (tref (tref dataset05 0) 2) i) 3) 1))
                            (tref (tref (pref (tref (tref dataset10 0) 2) i) 3) 1)
        ))
        (pset! global i range)
        ))
    (set! global-range global))))

(set-global-range)
;($ (println (tref (pref global-range1 55) 0)))

(bind-val alpha1 float 0.4)
(bind-val colors NVGcolor** 4)
(bind-func set-colors
  (lambda ()
    ;(set! colors (halloc 4))
    (pset! colors 0 (NVGcolor .6 .1 .7 alpha1))
    (pset! colors 1 (NVGcolor .1 .7 .6 alpha1))
    (pset! colors 2 (NVGcolor .7 .6 .1 alpha1))
    (pset! colors 3 (NVGcolor .1 .6 .7 alpha1))
    ))
(set-colors)
(bind-val parallel_rect Rect* (Rect (* 0.0 (convert width)) (* 0.05 (convert height)) (* 1.0 (convert width)) (* 0.9 (convert height))))
;($ (set! parallel_rect (Rect (* 0.0 (convert width)) (* 0.05 (convert height)) (* 1.0 (convert width)) (* 0.9 (convert height)))))

(bind-func draw_parallel_coordinate
  (let (
        (i:i64 0)
        (j:i64 0)
        (k:i64 0)
        (axis:Axis* null)
        (offset:float (convert 0))
        (offset2:float (convert 0))
        (range:Range* null)
        (minv:double 0.0)
        (maxv:double 0.0)
        (current:double 0.0)
        (current2:double 0.0)
        (normalized:double 0.0)
        (spacing:double 0.0)
        (spacingn:double 0.0)
        (cluster:i64 0)
        (crange:Range* null)
        (minr:double 0.0)
        (maxr:double 0.0)
        (padding 0.1)
        (current_line (halloc (+ (* (- n 1) 2) (* 2 n))))
        (vectors:double* null)
        (axes:Axis** null)
        (d:i64 0)
        (both:BothCCR* null)
        (clusters:Clusters null)
        (centroids:Centroids null)
        (data:Data* null)
        )
    (lambda (bounds:Rect* dataset:Dataset*)
      (set! data (tref dataset 0))
      (set! clusters (tuple-ref dataset 1))
      (set! centroids (tuple-ref dataset 2))
      (set! vectors (tuple-ref data 0))
      (set! axes (tuple-ref data 2))
      (set! d (tuple-ref data 3))
      (dotimes (i n)
        (set! cluster (pref clusters i))
        (dotimes (j d)
              (set! axis (pref axes j))
              (set! offset (tuple-ref axis 1))
              ;(set! range (tuple-ref axis 3))
              (set! range (pref global-range j))
              (set! minv (tuple-ref range 0))
              (set! maxv (tuple-ref range 1))
              (set! current (pref vectors (+ j (* i d))))
              (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current minv) (- maxv minv)))))
              (pset! current_line (* j 4) (convert (offset)) )
              (pset! current_line (+ (* j 4) 1) (convert normalized) )

              (if (< j (- d 1))
                (let ((a #t))
                  (set! offset2 (tuple-ref (pref axes (+ j 1)) 1))
                  (set! current2 (pref centroids (+ j (* cluster d)) ))
                  (if (= current2 0.0)
                    (set! normalized 0.0)
                    (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current2 minv) (- maxv minv)))))
                  )
                  (if (= current2 0.0)
                    (set! spacingn 0.0)
                    (set! spacingn (* 0.1 (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- (- current current2 ) minv) (- maxv minv))))))
                  )
                  (pset! current_line (+ (* j 4) 2) (convert (/ (+ offset offset2) (convert 2))) )
                  (pset! current_line (+ (* j 4) 3) (convert (+ spacingn normalized)) )
                )))
        (dv_draw_line_curve vg bounds current_line d (pref colors (pref clusters i))))
        (dotimes (i d)
          (dv_draw_axis_2D vg bounds (pref axes i)))
        #t
    )))

(bind-func intermediate:[float,float,float,double]*
  (lambda (old goal transition)
    (+ (* (convert transition) goal ) (* (convert (- 1.0 transition )) old ))
    ))


(bind-func pc_transition_data
  (let (
        (i:i64 0)
        (j:i64 0)
        (k:i64 0)
        (z:i64 0)
        (axis:Axis* null)
        (offset:float (convert 0))
        (offset2:float (convert 0))
        (range:Range* null)
        (minv:double 0.0)
        (maxv:double 0.0)
        (current:double 0.0)
        (current-old:double 0.0)
        (current-goal:double 0.0)
        (current2:double 0.0)
        (normalized:double 0.0)
        (spacing:double 0.0)
        (spacingn:double 0.0)
        (cluster:i64 0)
        (cluster-goal:i64 0)
        (crange:Range* null)
        (minr:double 0.0)
        (maxr:double 0.0)
        (padding 0.1)
        (current_line (halloc (+ (* (- n 1) 2) (* 2 n))))
        (vectors:double* null)
        (axes:Axis** null)
        (d:i64 0)
        (both:BothCCR* null)
        (clusters:Clusters null)
        (clusters-goal:Clusters null)
        (centroids:Centroids null)
        (data:Data* null)
        (data-goal:Data* null)
        (vectors-goal:double* null)
        (centroids-goal:Centroids null)
        (color:NVGcolor* null)
        (color-goal:NVGcolor* null)
        )
    (lambda (bounds:Rect* dataset:Dataset* dataset-goal:Dataset* transition:double tr1:bool tr2:bool tr3:bool tr4:bool)
      (set! data (tref dataset 0))
      (set! data-goal (tref dataset-goal 0))
      (set! clusters (tuple-ref dataset 1))
      (set! centroids (tuple-ref dataset 2))
      (set! vectors (tuple-ref data 0))
      (set! vectors-goal (tuple-ref data-goal 0))
      (set! clusters-goal (tuple-ref dataset-goal 1))
      (set! centroids-goal (tuple-ref dataset-goal 2))
      (set! axes (tuple-ref data 2))
      (set! d (tuple-ref data 3))
      (dotimes (i n)
        (set! cluster (pref clusters i))
        (set! cluster-goal (pref clusters-goal i))

        (dotimes (j d)
              (set! axis (pref axes j))
              (set! offset (tuple-ref axis 1))
              ;(set! range (tuple-ref axis 3))
              (set! range (pref global-range j))
              (set! minv (tuple-ref range 0))
              (set! maxv (tuple-ref range 1))

              (set! current (pref vectors (+ j (* i d))))
              (if (= tr1 1)
                (dotimes (z 1)
                  (set! current-goal (pref vectors-goal (+ j (* i d))))
                  (set! current (+ (* transition current-goal ) (* (- 1.0 transition ) current )))
              ))
              (if (or (= tr3 1) (= tr4 1))
                (set! current (pref vectors-goal (+ j (* i d))))
              )

              (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current minv) (- maxv minv)))))
              (pset! current_line (* j 4) (convert (offset)) )
              (pset! current_line (+ (* j 4) 1) (convert normalized) )

              (if (< j (- d 1))
                (let ((a #t))
                  (set! offset2 (tuple-ref (pref axes (+ j 1)) 1))
                  (set! current2 (pref centroids (+ j (* cluster d)) ))
                  (if (= tr4 #t)
                    (set! current2 (pref centroids-goal (+ j (* cluster-goal d)) ))
                  )
                  (if (= tr2 #t)
                    (dotimes (z 1)
                      (set! current2 (pref centroids (+ j (* cluster d)) ))
                      (set! current-goal (pref centroids-goal (+ j (* cluster d)) ))
                      (set! current2 (+ (* transition current-goal ) (* (- 1.0 transition ) current2 )))
                  ))
                  (if (= tr3 #t)
                    (dotimes (z 1)
                    (set! current-old (pref centroids-goal (+ j (* cluster d)) ))
                    (set! current-goal (pref centroids-goal (+ j (* cluster-goal d)) ))
                    (set! current2 (+ (* transition current-goal ) (* (- 1.0 transition ) current-old )))
                  ))
                  (if (= current2 0.0)
                    (set! normalized 0.0)
                    (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current2 minv) (- maxv minv)))))
                  )
                  (if (= current2 0.0)
                    (set! spacingn 0.0)
                    (set! spacingn (* 0.1 (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- (- current current2 ) minv) (- maxv minv))))))
                  )
                  (pset! current_line (+ (* j 4) 2) (convert (/ (+ offset offset2) (convert 2))) )
                  (pset! current_line (+ (* j 4) 3) (convert (+ spacingn normalized)) )
                )))
        (set! color (pref colors cluster))
        (if (= tr4 1)
          (dotimes (z 1)
            (set! color-goal (pref colors cluster-goal))
            (set! color (NVGcolor (intermediate (tref color 0) (tref color-goal 0) transition)
                                  (intermediate (tref color 1) (tref color-goal 1) transition)
                                  (intermediate (tref color 2) (tref color-goal 2) transition)
                                  alpha1))
        ))
        (dv_draw_line_curve vg bounds current_line d color))
        (dotimes (i d)
          (dv_draw_axis_2D vg bounds (pref axes i)))
        #t
    )))



(bind-func transform_data
  (lambda (data:Data*)
    data
    ))


(bind-func draw_barplot
  (let ((nlabs 5)
        (labs:float* (zalloc nlabs))
        (bars:float* (zalloc nlabs))
        (line:float* (zalloc (* 2 nlabs)))
        (i 0))
    (dotimes (i nlabs)
      (pset! labs i (* (convert i) (/ 1. (convert (- nlabs 1)))))
      ;; x positions should be in the middle of the bars
      (pset! line (* i 2) (+ (/ .5 (convert nlabs)) (* (convert i) (/ 1. (convert nlabs))))))
    (lambda (bounds:Rect*)
      (dotimes (i nlabs)
        (pset! bars i (+ .5 (* .3 (cos (* 0.00001 (convert (* (now) (+ i 1))))))))
        (pset! line (+ (* i 2) 1) (+ .5 (* .28 (cos (* 0.00001 (convert (* (now) (+ i 1)))))))))
      (dv_draw_bars vg bounds bars nlabs)
      (dv_draw_axis_labels_2D vg bounds labs nlabs labs nlabs)
      (dv_draw_axes_2D vg bounds)
      (dv_draw_title vg bounds "Barplot")
      (dv_draw_line vg bounds line nlabs null)
      void)))

(bind-func draw_scatterplot
  (let ((npoints 50)
        (points:float* (zalloc (* 2 npoints)))
        (i 0))
    (lambda (bounds:Rect*)
      (dotimes (i npoints)
        (pset! points (* i 2) (+ (* (cos (* .00000064 (convert (* i 2 (now))))) .5) .5))
        ;; (pset! points (+ 1 (* i 2)) (/ (convert i) (convert npoints)))
        (pset! points (+ 1 (* i 2)) (+ .5 (% (* 3.2 (cos (* 0.0000003 (convert (* (now) i) float)))) .5))))
      (dv_draw_scatter_points vg bounds points npoints (+ (* (cos (* .0000053 (convert (now)))) 3.) 5.))
      ;; (dv_draw_axis_labels_2D vg bounds points npoints points npoints)
      (dv_draw_axes_2D vg bounds)
      (dv_draw_title vg bounds "Scatterplot")
      void)))

(bind-func pre_loop
  (lambda ()
    (nvg_clear)
    (nvgBeginFrame vg width height pixel_ratio)
    (nvgResetTransform vg)
    ))

(bind-func post_loop
  (lambda ()
    (nvgEndFrame vg)
    ;(set! data (transform_data data1))
    (glfwPollEvents)
    (set_bg vg)
    (glfwSwapBuffers window)
    ))


(bind-func draw_title
  (lambda (title:i8*)
  (dv_draw_title vg parallel_rect title)
    ))

(bind-func nvg_draw_loop
    (lambda (time:i64 delta_t:double until:i64 dataset:Dataset* label:i8*)
      (pre_loop)
      ;(println until)
      (draw_title label)
      (draw_parallel_coordinate parallel_rect dataset)
      (post_loop)
      (let ((next_time (+ time (convert (* 44100. delta_t)))))
        (if (< next_time until)
        (callback next_time nvg_draw_loop next_time delta_t until dataset label)
        void))
      ))

(bind-func nvg_transition_loop
    (lambda (time:i64 delta_t:double until:i64 dataset:Dataset* dataset-goal:Dataset* transition:double increment:double type:i64 label:i8*)
      (pre_loop)
      ;(println until)
      (draw_title label)
      ;(println transition)
      (if (= type 0) (pc_transition_data parallel_rect dataset dataset-goal transition #t #t #f #f))
      (if (= type 1) (pc_transition_data parallel_rect dataset dataset-goal transition #f #f #t #f))
      (if (= type 2) (pc_transition_data parallel_rect dataset dataset-goal transition #f #f #f #t))

      (post_loop)
      (let ((next_time (+ time (convert (* 44100. delta_t)))))
        (if (< next_time until)
        (callback next_time nvg_transition_loop next_time delta_t until dataset dataset-goal (+ increment transition) increment type label)
        void))
      ))


(bind-func run_loop1
  (lambda ()

    (let ((last (now))
          (step (/ 1. 20.))
          (i:i64 0))

      (dotimes (i 3)

        (let ((t1 last)
              (t2 (+ t1 (* 44100 2)))
              (t3 (+ t2 (* 44100 1)))
              (t4 (+ t3 (* 44100 1)))
              (t5 (+ t4 (/ 44100 2)))
              (t6 (+ t5 (* 44100 1))))

          (nvg_draw_loop t1 step t2 (pref all_datasets i) "2000")
          (callback t2 nvg_transition_loop t2 step t3 (pref all_datasets i) (pref all_datasets (% (+ i 1 ) 3)) 0.0 (/ 1.0 (- (/ (/ (- (convert t3) (convert t2)) 44100.0) step) 1.0)) 0 "2000")
          (callback t3 nvg_transition_loop t3 step t4 (pref all_datasets i) (pref all_datasets (% (+ i 1) 3)) 0.0 (/ 1.0 (- (/ (/ (- (convert t4) (convert t3)) 44100.0) step) 1.0)) 1 "2000")
          (callback t4 nvg_transition_loop t4 step t5 (pref all_datasets i) (pref all_datasets (% (+ i 1) 3)) 0.0 (/ 1.0 (/ (/ (- (convert t5) (convert t4)) 44100.0) step)) 2 "2000")
          (set! last t6)

        ))

        (callback last run_loop1)

        )))

(run_loop1)

"
(bind-func run_loop1
  (lambda ()
    void
    ))
(bind-func nvg_draw_loop
  (lambda (time:i64 delta_t:double until:i64 dataset:Dataset* label:i8*)
    void
    ))

(bind-func run_loop1
  (lambda ()


    (let ((t1 (now))
          (step (/ 1. 20.))
          (t2 (+ t1 (convert (* 44100. step)))))

      (println 'running loop...'')
      (nvg_draw_loop t1 step t1 dataset00 '2000')
      (callback t2 run_loop1)

      )

      ;(nvg_draw_loop1 (now) (/ 1. 5.))
      )
    )


"
