
;;; parallel_coordinates.xtm:merged code and example --

;; Author: ***REMOVED***
;; Keywords: extempore
;; Required dylibs: libglfw3, libnanovg

;;; Commentary:

;;

;;; Code:
;;(sys:load "libs/external/system.xtm")


;; setup GLFW3 and nanovg
(sys:load "libs/external/glfw3.xtm")
(bind-val width  i32 1600)
(bind-val height i32 800)
(bind-val window GLFWwindow*
  (glfw_init_and_create_interaction_window (convert width) (convert height)))
(sys:load "libs/external/nanovg.xtm")
(bind-val vg NVGcontext* (nvg_create_context))
(bind-val pixel_ratio float (glfw_get_pixel_ratio window))

(call-as-xtlang
 (nvgCreateFont vg "default" "/Library/Fonts/Arial.ttf")
 (nvgFontFace vg "default"))

(bind-func set_bg
   (lambda (vg:NVGcontext*)
     (_nvgFillColor vg (NVGcolor 0.0 0.0 0.0 0.0))
     (nvgBeginPath vg)
     (nvgRect vg 0. 0. (convert width) (convert height))
     (nvgFill vg)))

;(dv_draw_axis_labels_2D.font_size 18)

;;(sys:load "libs/core/math_ext.xtm")

(sys:load "csv.xtm")
(sys:load "datavis-lib.xtm")
(sys:load "clustering-kmeans.xtm")

;;(set! current_line:float* (zalloc (+ (* (- n 1) 2) (* 2 n))))

(bind-func log
  (lambda (l:i8*)
    (println l)
    #t
    ))

(bind-val current_line float*)


(bind-val data00 Data* (load_csv "csv/school2000.csv"))
(bind-val data05 Data* (load_csv "csv/school2005.csv"))
(bind-val data10 Data* (load_csv "csv/school2010.csv"))
;($ (set! data10 (load_csv "csv/school2010.csv")))
(bind-val n i64 (tref data00 1))
(bind-val alpha1 float 0.4)
(bind-val colors NVGcolor** 4)
(bind-func set-colors
  (lambda ()
    ;(set! colors (halloc 4))
    (pset! colors 0 (NVGcolor .6 .1 .7 alpha1))
    (pset! colors 1 (NVGcolor .1 .7 .6 alpha1))
    (pset! colors 2 (NVGcolor .1 .7 .6 alpha1))
    (pset! colors 3 (NVGcolor .1 .6 .7 alpha1))
    ))
(set-colors)
(bind-val parallel_rect Rect* (Rect (* 0.0 (convert width)) (* 0.05 (convert height)) (* 1.0 (convert width)) (* 0.9 (convert height))))
;($ (set! parallel_rect (Rect (* 0.0 (convert width)) (* 0.05 (convert height)) (* 1.0 (convert width)) (* 0.9 (convert height)))))

(bind-func draw_parallel_coordinate
  (let (
        (i:i64 0)
        (j:i64 0)
        (k:i64 0)
        (axis:Axis* null)
        (offset:float (convert 0))
        (offset2:float (convert 0))
        (range:Range* null)
        (minv:double 0.0)
        (maxv:double 0.0)
        (current:double 0.0)
        (current2:double 0.0)
        (normalized:double 0.0)
        (spacing:double 0.0)
        (spacingn:double 0.0)
        (cluster:i64 0)
        (crange:Range* null)
        (minr:double 0.0)
        (maxr:double 0.0)
        (padding 0.1)
        (current_line (halloc (+ (* (- n 1) 2) (* 2 n))))
        (vectors:double* null)
        )
    (lambda (bounds:Rect* data:Data*)
      ;(println "1.1-in")
      (set! vectors (tuple-ref data 0))
      (let (
            (axes (tuple-ref data 2))
            (d (tuple-ref data 3))
            (both:BothCCR* (cluster-kmeans data 2))
            (clusters:Clusters (tuple-ref both 0))
            (centroids:Centroids (tuple-ref both 1))
           )
        (dotimes (i n)
          (set! cluster (pref clusters i))
          (dotimes (j d)
                (set! axis (pref axes j))
                (set! offset (tuple-ref axis 1))
                (set! range (tuple-ref axis 3))
                (set! minv (tuple-ref range 0))
                (set! maxv (tuple-ref range 1))
                (set! current (pref vectors (+ j (* i d))))
                (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current minv) (- maxv minv)))))
                (pset! current_line (* j 4) (convert (offset)) )
                (pset! current_line (+ (* j 4) 1) (convert normalized) )

                (if (< j (- d 1))
                  (let ((a #t))
                    (set! offset2 (tuple-ref (pref axes (+ j 1)) 1))
                    (set! current2 (pref centroids (+ j (* cluster d)) ))
                    (if (= current2 0.0)
                      (set! normalized 0.0)
                      (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current2 minv) (- maxv minv)))))
                    )
                    (if (= current2 0.0)
                      (set! spacingn 0.0)
                      (set! spacingn (* 0.1 (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- (- current current2 ) minv) (- maxv minv))))))
                    )
                    (pset! current_line (+ (* j 4) 2) (convert (/ (+ offset offset2) (convert 2))) )
                    (pset! current_line (+ (* j 4) 3) (convert (+ spacingn normalized)) )
                  )))
          (dv_draw_line_curve vg bounds current_line d (pref colors (pref clusters i)))
          #t
          )
        ;(set! axis (pref axes 0))
        ;(let ((lis (tref axis 4))
        ;      (lisn (length lis)))
        ;  (dotimes (i lisn)
        ;      (print (nth lis i))
        ;    )
        ;)
        ;(dotimes (i n)
        ;  (printf "%f, "(pref vectors (* i d)))
        ;)
        ;(println "")
        (dotimes (i d)
          ;;(dv_draw_axis_labels_2D vg bounds labs nlabs labs nlabs)
          (dv_draw_axis_2D vg bounds (pref axes i)))
        ;(println "2-out")
        #t
    ))))















(bind-func transform_data
  (lambda (data:Data*)
    data
    ))


(bind-func draw_barplot
  (let ((nlabs 5)
        (labs:float* (zalloc nlabs))
        (bars:float* (zalloc nlabs))
        (line:float* (zalloc (* 2 nlabs)))
        (i 0))
    (dotimes (i nlabs)
      (pset! labs i (* (convert i) (/ 1. (convert (- nlabs 1)))))
      ;; x positions should be in the middle of the bars
      (pset! line (* i 2) (+ (/ .5 (convert nlabs)) (* (convert i) (/ 1. (convert nlabs))))))
    (lambda (bounds:Rect*)
      (dotimes (i nlabs)
        (pset! bars i (+ .5 (* .3 (cos (* 0.00001 (convert (* (now) (+ i 1))))))))
        (pset! line (+ (* i 2) 1) (+ .5 (* .28 (cos (* 0.00001 (convert (* (now) (+ i 1)))))))))
      (dv_draw_bars vg bounds bars nlabs)
      (dv_draw_axis_labels_2D vg bounds labs nlabs labs nlabs)
      (dv_draw_axes_2D vg bounds)
      (dv_draw_title vg bounds "Barplot")
      (dv_draw_line vg bounds line nlabs null)
      void)))

(bind-func draw_scatterplot
  (let ((npoints 50)
        (points:float* (zalloc (* 2 npoints)))
        (i 0))
    (lambda (bounds:Rect*)
      (dotimes (i npoints)
        (pset! points (* i 2) (+ (* (cos (* .00000064 (convert (* i 2 (now))))) .5) .5))
        ;; (pset! points (+ 1 (* i 2)) (/ (convert i) (convert npoints)))
        (pset! points (+ 1 (* i 2)) (+ .5 (% (* 3.2 (cos (* 0.0000003 (convert (* (now) i) float)))) .5))))
      (dv_draw_scatter_points vg bounds points npoints (+ (* (cos (* .0000053 (convert (now)))) 3.) 5.))
      ;; (dv_draw_axis_labels_2D vg bounds points npoints points npoints)
      (dv_draw_axes_2D vg bounds)
      (dv_draw_title vg bounds "Scatterplot")
      void)))

(bind-func pre_loop
  (lambda ()
    (nvg_clear)
    (nvgBeginFrame vg width height pixel_ratio)
    (nvgResetTransform vg)
    ))

(bind-func post_loop
  (lambda ()
    (nvgEndFrame vg)
    ;(set! data (transform_data data1))
    (glfwPollEvents)
    (set_bg vg)
    (glfwSwapBuffers window)
    ))

(bind-func nvg_draw_loop
    (lambda (time:i64 delta_t:double until:i64 data:Data*)
      (pre_loop)
      ;(println until)
      (draw_parallel_coordinate parallel_rect data)
      (post_loop)
      (let ((next_time (+ time (convert (* 44100. delta_t)))))
        (if (< next_time until)
        (callback next_time nvg_draw_loop next_time delta_t until data)
        void))
      ))


(bind-func run_loop
  (lambda ()


    (let ((t1 (now))
          (t2 (+ t1 (* 44100 4)))
          (t3 (+ t2 (* 44100 4)))
          (t4 (+ t3 (* 44100 4))))

      (println "running loop...")
      (nvg_draw_loop t1 (/ 1. 5.) t2 data00)
      (callback t2 nvg_draw_loop t2 (/ 1. 5.) t3 data05)
      (callback t3 nvg_draw_loop t3 (/ 1. 5.) t4 data10)

      (callback t4 run_loop)

      )

      ;(nvg_draw_loop1 (now) (/ 1. 5.))
      )
    )

(run_loop)

(bind-func setData
  (lambda (name)
    (set! data (load_csv name))
    ))

($ (setData "basic.csv"))

($ (set! data10 (load_csv "csv/school2010.csv")))

(bind-func nvg_draw_loop
  (lambda (time:i64 delta_t:double)
    void
    ))
